<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hack Your Design!]]></title>
  <link href="http://blog.toshimaru.net/atom.xml" rel="self"/>
  <link href="http://blog.toshimaru.net/"/>
  <updated>2016-02-12T15:56:21+00:00</updated>
  <id>http://blog.toshimaru.net/</id>
  <author>
    <name><![CDATA[Toshimaru]]></name>
  </author>

  
  <entry>
    <title type="html"><![CDATA[接続元のグローバルIP出すやつ作った]]></title>
    <link href="http://blog.toshimaru.net/gae-ip-info/"/>
    <updated>2016-02-10T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/gae-ip-info</id>
    <content type="html"><![CDATA[<p><a href="http://www.ugtop.com/spill.shtml">確認くん</a>とかいちいち検索してページにいったりするのがダルかったので、自分のわかりやすいURLでGoogle App Engine上にPHPで接続元グローバルIP出すやつ作った。</p>

<p><a href="http://ip.toshimaru.net/">Your IP address info</a></p>

<h2 id="section">裏機能</h2>

<p>コマンドラインで簡単に抽出できるように<code class="highlighter-rouge">curl</code>で叩いたらIPだけ出力するような裏機能付けた。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ curl ip.toshimaru.net
xx.xx.xx.xx
</code></pre>
</div>

<h2 id="google-app-engine">Google App Engine</h2>

<p>Google App Engine、一昔前はとっつきにくかったけど今は管理画面も使いやすくなってドキュメントも丁寧になってきたしデプロイ周りのCLIツールも整ってきているので良い感じである。</p>

<p>Herokuが有料になった今、個人サービスでなにかさっと作りたいときはGAEは良さそう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ひどいコードを書いてもよいとき]]></title>
    <link href="http://blog.toshimaru.net/why-you-should-write-shitty-code/"/>
    <updated>2016-02-08T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/why-you-should-write-shitty-code</id>
    <content type="html"><![CDATA[<p><a href="http://hitode909.hatenablog.com/entry/2016/02/08/140232">なぜひどいコードを書いてはいけないか - hitode909の日記</a></p>

<p>ひどいコードを書いてもよいときとは<img class="emoji" title=":question:" alt=":question:" src="https://assets.github.com/images/icons/emoji/unicode/2753.png" height="20" width="20" align="absmiddle" /></p>

<ul>
  <li>そもそもひどくないコードを書けるだけの技術力がない</li>
  <li>プロジェクトの生産期間が短い</li>
  <li>プロダクトの寿命が短い</li>
  <li>将来アーキテクチャを作り直すことが決まっている</li>
  <li>自分が近い将来退職する</li>
  <li>技術的負債を残したい</li>
</ul>

<p>良いコード<img class="emoji" title=":innocent:" alt=":innocent:" src="https://assets.github.com/images/icons/emoji/unicode/1f607.png" height="20" width="20" align="absmiddle" />と悪いコード<img class="emoji" title=":imp:" alt=":imp:" src="https://assets.github.com/images/icons/emoji/unicode/1f47f.png" height="20" width="20" align="absmiddle" />の分別がつかない新卒くんとかは好むと好まざるとにかかわらずひどいコードを書いてしまうときもある。メンターはきちんと導いていかなければならない。</p>

<p>プロジェクトの生産期間が短かったり、プロダクトの寿命が極端に短いとわかっているものであればひどいコードを書いてもよい。<img class="emoji" title=":imp:" alt=":imp:" src="https://assets.github.com/images/icons/emoji/unicode/1f47f.png" height="20" width="20" align="absmiddle" /> ひどいコードとわかっていても時間が足りなければ直せないし、直したとしてもその成果はプロダクトの寿命と共に終わる。ただし長期的にメンテンナンスをしていくのであればこの限りではない。</p>

<p>言語選択とかフレームワーク選定とかデータベース設計とかアーキテクチャレベルで作り直すことを将来想定しているのであれば、ひどいコードを書いてもよい。<img class="emoji" title=":imp:" alt=":imp:" src="https://assets.github.com/images/icons/emoji/unicode/1f47f.png" height="20" width="20" align="absmiddle" /> かの有名なFacebookだって最初はひどいコードから始まって大きくなっているんだ<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。それを未来の優秀なエンジニアたちが塗り替えていったんだ。ビジネス <img class="emoji" title=":moneybag:" alt=":moneybag:" src="https://assets.github.com/images/icons/emoji/unicode/1f4b0.png" height="20" width="20" align="absmiddle" /> を作るのにいいコードは要らない。</p>

<p>あたなは近い将来退職することを目論んでいて現在の職場に少ならからずのヘイトを溜めている。さぁ復讐のときだ。技術的負債を目いっぱい残してやろう。<img class="emoji" title=":imp:" alt=":imp:" src="https://assets.github.com/images/icons/emoji/unicode/1f47f.png" height="20" width="20" align="absmiddle" /></p>

<h3 id="section">過去に書いた関連エントリ</h3>
<ul>
  <li><a href="/mentenability/">メンテナンス性の高いコードを書く意義とは</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://gist.github.com/nikcub/3833406">Facebook PHP Source Code from August 2007</a> <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jekyll 3にアップデートした]]></title>
    <link href="http://blog.toshimaru.net/jekyll-3/"/>
    <updated>2016-01-28T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/jekyll-3</id>
    <content type="html"><![CDATA[<p>本サイトは<a href="https://pages.github.com/">GitHub Pages</a>の上にスタティックサイトジェネレーターであるところの<a href="https://jekyllrb.com/">Jekyll</a>を使ってサイト構築しているのだが、それを先日Jekyll 2からJekyll 3へと上げた。</p>

<p><a href="https://jekyllrb.com/news/2015/10/26/jekyll-3-0-released/">Jekyll 3.0 Released</a></p>

<p>Jekyll 3の主な変更点は以下だ。</p>

<h2 id="section">インクリメンタルビルドのサポート</h2>

<p>これにより10秒かかってたページ再生成の処理が3秒くらいで終わるようになった。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ jekyll serve
...
Server address: http://127.0.0.1:4000/
Server running... press ctrl-c to stop.
  Regenerating: 1 file(s) changed at 2016-01-28 23:26:28 ...done in 10.443565 seconds.
  Regenerating: 1 file(s) changed at 2016-01-28 23:26:39 ...done in 10.440658 seconds.

$ jekyll serve --incremental
...
Server address: http://127.0.0.1:4000/
Server running... press ctrl-c to stop.
  Regenerating: 1 file(s) changed at 2016-01-28 23:28:47 ...done in 3.404143 seconds.
  Regenerating: 1 file(s) changed at 2016-01-28 23:29:01 ...done in 3.478217 seconds.
</code></pre>
</div>

<h2 id="ruby-193">Ruby 1.9.3のサポートドロップ</h2>

<p>そろそろRuby 1.9.3以上ではなく、Ruby 2.0以上が当たり前な世界観になってきつつある。</p>

<h2 id="gem">いくつかのgemファイルが分離された</h2>

<p><a href="https://github.com/jekyll/jekyll-coffeescript">jekyll-coffeescript</a>や<a href="https://github.com/jekyll/jekyll-paginate">jekyll-paginate</a>など、静的サイト作成において必須でない機能はgemとして分離され必要であればプラガブルに導入する形式になった。正しい進化。</p>

<h2 id="section-1">ファイル名によるタイトル付が可能に</h2>

<p>日本語タイトル使っている僕にはあんまり関係なさそう。</p>

<h2 id="jekyll-3--pull-request">Jekyll 3 対応 Pull Request</h2>

<p><a href="https://github.com/toshimaru/blog.toshimaru.net/pull/31">Jekyll3 by toshimaru · Pull Request #31 · toshimaru/blog.toshimaru.net</a></p>

<h2 id="jekyll-gem-">jekyll gem 作ってる</h2>

<p>余談だがサイト構築の上で必要なgemを２つほど作った。</p>

<ul>
  <li><a href="https://github.com/toshimaru/jekyll-tagging-related_posts">jekyll-tagging-related_posts</a></li>
  <li><a href="https://github.com/toshimaru/jekyll-toc">jekyll-toc</a></li>
</ul>

<h2 id="road-to-jekyll-31">Road to Jekyll 3.1</h2>

<p><a href="https://jekyllrb.com/news/2016/01/24/jekyll-3-1-0-released/">Jekyll 3.1.0 Released</a></p>

<p>もう出てるので近いうちに上げる。</p>

<hr />

<p>追記: 上げた。 <a href="https://github.com/toshimaru/blog.toshimaru.net/pull/34">Bundle Update on 2016-01-30 by deppbot · Pull Request #34 · toshimaru/blog.toshimaru.net</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[認定スクラムマスター研修に行ってきました]]></title>
    <link href="http://blog.toshimaru.net/scrum-training/"/>
    <updated>2016-01-20T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/scrum-training</id>
    <content type="html"><![CDATA[<p>昨年末にスクラムマスター研修を受けてきて、認定スクラムマスター (CSM)となりました。スクラムマスター研修で学んだこととして社内に共有した内容をこちらにも共有してみようと思います。</p>

<h2 id="scrum-vs-agile-">Scrum vs Agile 〜歴史から学ぶ〜</h2>

<ul>
  <li>1993年: スクラム誕生</li>
  <li>2001年: アジャイルソフトウェア開発宣言
    <ul>
      <li>アジャイルマニフェスト: <a href="http://agilemanifesto.org/iso/ja/manifesto.html">アジャイルソフトウェア開発宣言</a></li>
      <li>アジャイル原則:  <a href="http://agilemanifesto.org/iso/ja/principles.html">アジャイル宣言の背後にある原則</a></li>
    </ul>
  </li>
</ul>

<p>アジャイルは「より良い開発/方法を探している」という状態のことです。状態なので原理的には「アジャイル開発をしている」という表現は正しくありません。振り返ってみて「あのプロジェクトはアジャイルだった」と評価できるもの。極端に言うといわゆるウォーターフォール型の開発も１つのアジャイルと定義することもできます。</p>

<p><em>Don’t do agile, be agile</em> （訳: アジャイル開発をするな、アジャイルであれ）</p>

<p>スクラムのほうがアジャイルより歴史的には古く、アジャイルの定義が曖昧な一方、スクラムはきちんと確立された方法論で現在もアップデートされ続けているフレームワークです(年２回)。ただ出版社のマーケティング戦略的に「アジャイル」というバズワードを使わなきゃ本が売れないという理由もあってか、世の中には＜アジャイルという皮を被った何か＞が氾濫しています。「アジャイル」という魔法のコトバに惑わされてはいけないのです。</p>

<h2 id="section">スクラムとは何か？</h2>

<p>スクラムとは <strong>＜現状を把握するためのフレームワーク＞</strong>。どのプロジェクトにおいても現状を把握した結果、大体において問題はあることから <strong>＜問題を発見するフレームワーク＞</strong> と言われることもあります。</p>

<p>なのでポイント（超重要！）は、スクラムをやったからといって</p>

<ul>
  <li><strong>生産性は向上しません</strong></li>
  <li><strong>人が成長することはありません</strong></li>
  <li><strong>プロダクトが改善することはありません</strong></li>
</ul>

<p>あくまでもこれらは、現状を把握した結果として期待できるものであって、スクラムをやれば必ず得られる結果というわけではありません。スクラムもまた、銀の弾丸ではないのです。</p>

<p>逆にチームの現状を把握できていないのであれば、それはスクラムとは呼べない。そして「スクラムは優秀な人じゃなければできない」というのも間違い。優秀じゃない人でも現状を把握してそこそこの成果を出せるようにするのがスクラムのフレームワークです。</p>

<h2 id="section-1">スクラムのルール</h2>

<p>全部で19コあります。</p>

<p><img src="/images/posts/scrum/scrum1.png" alt="scrum" /></p>

<h3 id="section-2">スクラムの三本柱</h3>

<ol>
  <li><strong>透明性</strong> – Transparency</li>
  <li><strong>検証</strong> – Inspect</li>
  <li><strong>適合</strong> (検証に基づいた適合) – Adapt</li>
</ol>

<h3 id="section-3">スクラムの３つの役割</h3>

<ol>
  <li><strong>プロダクトオーナー</strong>
    <ul>
      <li>チームのROIを最大化させる（ビジネスのROIではないということに注意）</li>
    </ul>
  </li>
  <li><strong>スクラムマスター</strong>
    <ul>
      <li>開発が Scrum と呼べる状態にする</li>
      <li><strong>スクラムじゃない方法を提案するのもまた、スクラムマスターの役割</strong></li>
    </ul>
  </li>
  <li><strong>チーム</strong></li>
</ol>

<p><strong>7人±2人</strong> が１つのスクラムチームを構成するのがのぞましい。</p>

<h3 id="section-4">スクラムの5つのセレモニー</h3>

<ol>
  <li><strong>Sprint Planning – スプリント計画</strong>
    <ul>
      <li>短期計画</li>
      <li>何を実現しようとしているのかを明確に</li>
      <li>どの順番（優先順位）で開発を進めるのか</li>
    </ul>
  </li>
  <li><strong>Daily Scrum – デイリースクラム/朝会（朝じゃなくてもよい）</strong>
    <ul>
      <li>15分間</li>
      <li>毎日の学習を共有</li>
      <li>議論は行わない</li>
    </ul>
  </li>
  <li><strong>Product Backlog Refinement – プロダクトバックログ見直し</strong>
    <ul>
      <li>中長期計画（現在のスプリントは含まれないことに注意）</li>
      <li>スプリントの5-10%使って見直しを行う</li>
    </ul>
  </li>
  <li><strong>Sprint Review – スプリントレビュー</strong>
    <ul>
      <li>動くプロダクト・ドキュメントで成果を確認する</li>
      <li>プロダクト触ってもっとプロダクトを良くする</li>
    </ul>
  </li>
  <li><strong>Sprint Retrospective – スプリントレトロスペクティブ/振り返り</strong>
    <ul>
      <li>チームが生産性を高めるために取らなきゃいけないアクションを1つ以上決める</li>
    </ul>
  </li>
</ol>

<p><img src="/images/posts/scrum/scrum2.jpeg" alt="scrum sprint" /></p>

<h3 id="section-5">アーチファクト</h3>

<p>アーティファクト、成果物とでも訳しましょうか。下記４つ。</p>

<ol>
  <li><strong>スプリントバックログ</strong></li>
  <li><strong>プロダクトバックログ</strong></li>
  <li><strong>Impediment List</strong> - 障害リスト</li>
  <li><strong>Acceptance Criteria</strong> - 受け入れ条件</li>
</ol>

<h3 id="section-6">その他</h3>
<ul>
  <li><strong>Sprint</strong> - スプリント</li>
  <li><strong>Sprint Stop</strong> - スプリント停止</li>
  <li><strong>DONE</strong> - 製品が完了する</li>
  <li><strong>Potentially shippable product increment</strong> – 出荷可能な製品をリリースする</li>
</ul>

<h2 id="section-7">スクラムが適さないシーン</h2>

<ul>
  <li>プロダクトの生産期間が短い
    <ul>
      <li>例) 2ヶ月で終わってしまうプロジェクト</li>
      <li>スクラムはチームビルディングで最低３ヶ月かかる。そしてその３ヶ月を反復してチームを改善させていく。つまり３ヶ月以内のプロジェクトでスクラムを行うのは難しい。（やれなくもないが）</li>
    </ul>
  </li>
  <li>要件・技術が単純なプロダクト
    <ul>
      <li>スクラムは要件・技術的要素が複雑な場合に適したアプローチ</li>
    </ul>
  </li>
</ul>

<h2 id="section-8">自律的なチームとは</h2>

<ol>
  <li>チームの明確なゴールがある</li>
  <li>チームの明確なバウンダリー（境界線）がある</li>
</ol>

<p>「自律的なチームかどうかの判断基準は何？」への回答は「<strong>個人がチームのゴールを達成するために何をすべきか0.1秒以内に判別し行動できる</strong>」といえます。</p>

<h2 id="section-9">見積もり方法</h2>

<ol>
  <li><strong>相対見積もり</strong>
    <ul>
      <li>一番簡単なタスクのポイントが1だとしてそれに対する相対的な見積もり</li>
      <li>プロダクトバックログアイテムはこちらの見積もり方法が適している</li>
    </ul>
  </li>
  <li><strong>絶対見積もり</strong>
    <ul>
      <li>xx時間とかの見積もり</li>
      <li>スプリントバックログアイテムにはこちらの方法が適している</li>
      <li>1スプリントバックログアイテムが0.5時間〜1時間になるのが理想的な状態</li>
    </ul>
  </li>
</ol>

<p>ここで重要なポイントとしては <strong>スクラムマスターは絶対に計画せずにチームが進むことを許容してはいけません</strong> 。スクラムをやるなら <strong>徹底的に計画してください。妥協は許されません</strong> ここがスクラムをやる上でのチームが持たなければならない＜覚悟＞となります。逆に言うとこの覚悟が持てないならスクラムをやるべきではありません。</p>

<h2 id="done">DONE</h2>

<p>DONEは Definition of done のことです。そして Definition of done は doneとundoneの２つが含まれます。</p>

<p>説明します。例えば１つのタスクに関して、例えばログイン機能としましょう。ログイン機能のDONEとして何をイメージしますか？「フォームに正しい値を入力して正しくログインできること」「間違った値を入力してログインできないこと」「変な値でバリデーションエラーメッセージがでること」などが簡単に思い浮かぶと思います。</p>

<p>ではそれが本当にログイン機能はDONEなのでしょうか。違います、DONEにはログイン機能の単体テストやその結合テスト、さらにはセキュリティテスト、負荷テスト、またはその機能のドキュメンテーションも全て含めてdoneです。そしてDONEにはそれで完了しているdoneとそれで完了しなかった、例えばこのケースで言うと「テストは後でかこう」「セキュリティ試験は全ての機能が完成してから実施」などのundoneも含まれています。</p>

<p>このundoneを後回しになって積み上がった状態がプロジェクトの炎上状態であり、スクラムとして不健全な状態です。健全なスクラムは１スプリント毎にこのundoenを着実に消化していきます。</p>

<h2 id="section-10">プロダクトバックログの書き方</h2>

<p>研修ではユーザーストーリーとAcceptance Criteriaの２つを書いて１つのプロダクトバックログアイテムとしました。</p>

<ul>
  <li><strong>ユーザーストーリー</strong>: {who}として {what}がほしい なぜなら{why}だから</li>
  <li><strong>Acceptance Criteria</strong>: 受け入れ条件 ユーザーストーリーが達成できたといえる <strong>誰が見てもわかる明確な条件</strong></li>
</ul>

<h2 id="section-11">ベロシティ</h2>

<p>これらのプロダクトバックログアイテムに対して先ほどの見積もりのポイントを付けていきます。そして<strong>1スプリント中にチームが消化できるポイント数のことをベロシティ</strong>といいます。</p>

<p>このベロシティは安定させるべきです。もし安定していないのならば、それはポイントの付け方が間違っているかチームに何か問題がある可能性が高いです。</p>

<h2 id="section-12">スクラムが成功している状態とは？</h2>

<p>スクラムチームとして3ヶ月で46%生産性が向上している状態がスクラムが成功している状態です。じゃあ46%向上している状態とはどう測ったらよいかというと、講師曰く先ほど言及したundoneが3ヶ月というスパンで1つでも消化できていれば46%生産性が上がったと言っていいとのことでした。しかしこれは非常に難しいことで、どんなに成功しているスクラムチームでも1年に1回でもそれが達成できていればうまくできているほうだとのことでした。</p>

<h2 id="section-13">スクラムマスター役割・スキル</h2>
<ul>
  <li><strong>状況分析</strong>: シチュエーショニング</li>
  <li><strong>ティーチング</strong></li>
  <li><strong>ファシリテーティング</strong></li>
  <li><strong>メンタリング</strong></li>
  <li><strong>コーチング</strong></li>
</ul>

<p>そしてスクラムマスターはこれらの行為をやるだけで満足してはいけません。やった上で <strong>結果が出ないと意味がありません。</strong> つまりティーチングをやったからスクラムマスターの役割を果たしたとはいえず、ティーチングをやった結果、それを受けた者の行動が変わることも含めてスクラムマスターの役割ということです。</p>

<p>「謙虚さ」と同時に「屈強さ」がスクラムマスターには必要です。</p>

<h2 id="section-14">受講してみての感想</h2>

<p>今回のスクラムマスター研修では「スクラムとは何か」を原理的な立場から学びました。</p>

<p>受講してわかったことは世の開発現場には似非スクラムが溢れているなーってことでした。スプリント回しているからスクラムですとか、カンバンでタスク管理して朝会やってスクラムですとか、リソース足りないのでうちはチームとスクラムマスター兼任してますとか…。</p>

<p>スクラムの基本原則から言うと、スクラムマスターなどの役割の兼任はNGですし、スクラムは具体的なタスク管理手法は規定していないのでカンバンでやろうとJIRAでやろうとGithub Issueでやろうとそれはスクラムと関係ありません。朝会以外にもスクラムの大事なセレモニーはあって必ずそれらはスキップしてはいけないものとなってますし、スプリント回すにしても、ちゃんとそのスプリントは計画とあっていたのかとか、ちゃんとスプリントの成果物として受け入れ条件をクリアする品質で成果が上がってるかとか、その間に差し込みタスクがないかとかいろいろやらなきゃいけないこと・考えることはあります。</p>

<p>そして感じたこととしては、スタートアップのアーリーフェーズだとなかなか原理的な意味でのスクラムは難しいのではということでした。スクラムやりたくともリソースが全然足りないのでスクラムマスター、プロダクトオーナーはそもそも置けないとか、スクラムチームを兼任せざるを得ないとか。</p>

<p>また人の出入り（特に新しいメンバーを迎えるパターン）も激しいと思うのでそうなるとスクラムチームは再度チームビルディングからやり直さなければなりません（このチームビルディングで1Sprintは消費すると言われています）。</p>

<p>なのでこういった開発現場で出来ることとしてはスクラムのフレームワークの中で良いと思うもの、有効だと思うものを選択して＜スクラムエッセンスを取り入れた開発＞を実践することではないでしょうか。</p>

<p>一方で上記に書いたように「スクラムじゃない別の方法を提案するのもスクラムマスターの役割」と書きました。なのでスクラムにこだわる必要は全然なくて、スクラムがチームにマッチしないと思うならスクラムマスターは別の手法を提案できなきゃダメです。例えばそれがウォーターフォールでもいいしDDDでもいいしリーンスタートアップだっていいのです。</p>

<p>そういう意味でスクラムマスターは(おそらく皆が)思っている以上にその役割を全うすることが難しいものだと感じました。</p>

<h2 id="section-15">参考になりそうな他の人の体験記</h2>

<p>スクラムマスター研修に行かれた他の方の体験記を紹介します。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/ohbtp9vAjuJX6L" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/yangiYa/csm2014-1114" title="認定スクラムマスター研修に行ってきました" target="_blank">認定スクラムマスター研修に行ってきました</a> </strong> from <strong><a href="//www.slideshare.net/yangiYa" target="_blank">Hajime Yanagawa</a></strong> </div>

<ul>
  <li><a href="http://makopi23.blog.fc2.com/blog-entry-155.html">makopi23のブログ 認定スクラムマスター研修（CSM）を振り返る</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのJSONパーサーのパース速度比較]]></title>
    <link href="http://blog.toshimaru.net/json-parser-benchmark/"/>
    <updated>2015-12-13T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/json-parser-benchmark</id>
    <content type="html"><![CDATA[<p>標準のJSONパーサーとは別に<a href="https://www.ruby-toolbox.com/categories/JSON_Parsers">いくつかのJSONパーサー</a>実装がRuby gemにはある。それらを比較としてベンチマークとってみた。</p>

<h2 id="section">前提</h2>
<ul>
  <li>Ruby 2.2.2 を使います</li>
  <li><a href="https://github.com/evanphx/benchmark-ips">benchmark-ips</a>でベンチとる</li>
  <li>パースするJSONは30KB程度のサイズ</li>
  <li>比較対象は下記3つ
    <ul>
      <li><a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/json/rdoc/JSON.html">Module: JSON</a></li>
      <li><a href="https://github.com/brianmario/yajl-ruby">yajl</a></li>
      <li><a href="https://github.com/ohler55/oj">oj</a></li>
    </ul>
  </li>
</ul>

<h2 id="ruby-code">Ruby code</h2>

<p>書いてみた。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'uri'</span>
<span class="nb">require</span> <span class="s1">'net/http'</span>
<span class="nb">require</span> <span class="s1">'json'</span>
<span class="nb">require</span> <span class="s1">'yajl'</span>
<span class="nb">require</span> <span class="s1">'oj'</span>
<span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="n">uri</span> <span class="o">=</span> <span class="no">URI</span> <span class="s2">"http://complex/json/url.json"</span>
<span class="n">response</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span> <span class="n">uri</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"JSON.parse"</span><span class="p">)</span> <span class="p">{</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"Yajl"</span><span class="p">)</span> <span class="p">{</span> <span class="no">Yajl</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"Oj"</span><span class="p">)</span> <span class="p">{</span> <span class="no">Oj</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">compare!</span>
<span class="k">end</span></code></pre></figure>

<h2 id="result">Result</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>Calculating -------------------------------------
          JSON.parse    99.000  i/100ms
                Yajl   108.000  i/100ms
                  Oj   173.000  i/100ms
-------------------------------------------------
          JSON.parse      1.123k (± 8.4%) i/s -      5.643k
                Yajl      1.105k (± 2.8%) i/s -      5.616k
                  Oj      1.838k (± 3.2%) i/s -      9.342k

Comparison:
                  Oj:     1838.3 i/s
          JSON.parse:     1123.1 i/s - 1.64x slower
                Yajl:     1105.2 i/s - 1.66x slower
</code></pre>
</div>

<p>OjがJSON.parseやYajlより1.5倍〜1.8倍ほど高速という結果が得られた。</p>

<h2 id="section-1">まとめ</h2>

<p>Oj使ってこ。</p>

<h2 id="section-2">追記</h2>

<p>こんなPRを見つけた。 <a href="https://github.com/fluent/fluentd/pull/748">Use ‘oj’ for performance improvement when oj is installed by repeatedly · Pull Request #748 · fluent/fluentd</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON Schemaについて発表した]]></title>
    <link href="http://blog.toshimaru.net/json-schema-collaboration/"/>
    <updated>2015-12-09T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/json-schema-collaboration</id>
    <content type="html"><![CDATA[<p>「JSON Schemaでバックエンドエンジニアとフロントエンドエンジニアがコラボする」と題して<a href="http://gunosy-beer.connpass.com/event/22825/">エムスリー x Gunosy Beer bash</a>で発表してきました。</p>

<p>当日ハッシュタグ: <a href="https://twitter.com/hashtag/gunosybeer?src=hash">#gunosybeer hashtag on Twitter</a></p>

<h2 id="img-classemoji-titlepointdown-altpointdown-srchttpsassetsgithubcomimagesiconsemojiunicode1f447png-height20-width20-alignabsmiddle-">発表資料<img class="emoji" title=":point_down:" alt=":point_down:" src="https://assets.github.com/images/icons/emoji/unicode/1f447.png" height="20" width="20" align="absmiddle" /></h2>

<script async="" class="speakerdeck-embed" data-id="ddf8953b3746496a848dd7e4038ece4e" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<h1 id="types-of-json-schema">2 Types of JSON Schema</h1>

<p><a href="http://json-schema.org/">JSON Schema and Hyper-Schema</a></p>

<ul>
  <li>JSON Schema</li>
  <li>JSON Hyper-Schema</li>
</ul>

<p><img src="/images/posts/jsonschema/json-schema.png" alt="" /></p>

<h2 id="json-schema">JSON Schema</h2>
<ul>
  <li>JSONの <strong>データフォーマット</strong> を記述する</li>
  <li>人間にも機械にもわかりやすいドキュメント</li>
  <li>フォームでサブミットするデータのバリデーションに使える</li>
  <li>自動テストにも使える</li>
</ul>

<h2 id="json-hyper-schema">JSON Hyper-Schema</h2>
<ul>
  <li><strong>Web APIの仕様</strong> を記述する</li>
  <li>APIで期待するデータをJSON Schemaの形式で記述</li>
  <li>日本ではこっちの方がポピュラー？</li>
</ul>

<p>観測範囲内だと日本のコミュニティでJSON Schemaといったときにこちらを指すことが多い気がする。</p>

<h2 id="section">コラボレーション図</h2>

<p>JSON Schemaでコラボレーションした事例を紹介するよ。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>+------------------+
|                  |
|  Client-side JS  |
|     (React)      |
|                  |
+---+--------+-----+
    |        ^
    |        |            +---------------+
    |  JSON  |  &lt;-------- |  JSON Schema  |
    |        |            +---------------+
    v        |
+---+--------+-----+
|                  |
| Server-side API  |
|     (Rails)      |
|                  |
+------------------+
</code></pre>
</div>

<h2 id="json-schema-for-us">JSON Schema for us</h2>
<ul>
  <li>For Humans
    <ul>
      <li>Clear specification</li>
    </ul>
  </li>
  <li>For Apps
    <ul>
      <li>useful for Validation</li>
      <li>useful for Test</li>
      <li>etc.</li>
    </ul>
  </li>
</ul>

<h2 id="repositories">Repositories</h2>
<ul>
  <li><img class="emoji" title=":point_down:" alt=":point_down:" src="https://assets.github.com/images/icons/emoji/unicode/1f447.png" height="20" width="20" align="absmiddle" /> Rails API Repo <img class="emoji" title=":point_down:" alt=":point_down:" src="https://assets.github.com/images/icons/emoji/unicode/1f447.png" height="20" width="20" align="absmiddle" /></li>
  <li><img class="emoji" title=":point_right:" alt=":point_right:" src="https://assets.github.com/images/icons/emoji/unicode/1f449.png" height="20" width="20" align="absmiddle" /> <strong>JSON Schema Repo</strong> <img class="emoji" title=":point_left:" alt=":point_left:" src="https://assets.github.com/images/icons/emoji/unicode/1f448.png" height="20" width="20" align="absmiddle" /></li>
  <li><img class="emoji" title=":point_up_2:" alt=":point_up_2:" src="https://assets.github.com/images/icons/emoji/unicode/1f446.png" height="20" width="20" align="absmiddle" /> Frontend Repo <img class="emoji" title=":point_up_2:" alt=":point_up_2:" src="https://assets.github.com/images/icons/emoji/unicode/1f446.png" height="20" width="20" align="absmiddle" /></li>
</ul>

<p>バックエンドAPIのレポジトリ、フロントエンドのJSレポジトリ、共通で使うJSON Schemaのためのレポジトリ、これら３つを用意した。</p>

<h2 id="workflow">Workflow</h2>

<ol>
  <li>必要なAPIとそこに含まれるべきデータを洗い出し</li>
  <li>1をJSON Schemaに落としこむ</li>
  <li>プルリク！</li>
</ol>

<p>1は仕様・ワイヤーをもとにマークダウンでもスプレッドシートでも荒くアウトプット出す。</p>

<p>バックエンドエンジニアとフロントエンドエンジニアが共通認識を深めながらJSON Schemaレポジトリを育てていく。</p>

<p><img src="/images/posts/jsonschema/schema-pr.png" alt="" /></p>

<h2 id="get-usersid">GET /users/{id}</h2>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="c1"># user.schema.yml</span>
<span class="s">$schema</span><span class="pi">:</span> <span class="s">http://json-schema.org/draft-04/schema#</span>
<span class="s">title</span><span class="pi">:</span> <span class="s">User</span>
<span class="s">description</span><span class="pi">:</span> <span class="s">An User</span>
<span class="s">type</span><span class="pi">:</span> <span class="s">object</span>
<span class="s">properties</span><span class="pi">:</span>
  <span class="s">id</span><span class="pi">:</span>
    <span class="s">type</span><span class="pi">:</span> <span class="s">integer</span>
  <span class="s">email</span><span class="pi">:</span>
    <span class="s">type</span><span class="pi">:</span> <span class="s">string</span>
    <span class="s">format</span><span class="pi">:</span> <span class="s">email</span>
  <span class="s">name</span><span class="pi">:</span>
    <span class="s">type</span><span class="pi">:</span> <span class="s">string</span>
    <span class="s">minLength</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">maxLength</span><span class="pi">:</span> <span class="s">32</span>
<span class="s">required</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">id</span>
  <span class="pi">-</span> <span class="s">email</span>
  <span class="pi">-</span> <span class="s">name</span></code></pre></figure>

<p><code class="highlighter-rouge">PUT /users/{id}</code>とかもスキーマ使いまわせる。</p>

<h2 id="json-schema-validation">JSON Schema Validation</h2>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'json-schema'</span>

<span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"type"</span> <span class="o">=&gt;</span> <span class="s2">"object"</span><span class="p">,</span>
  <span class="s2">"required"</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">],</span>
  <span class="s2">"properties"</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="s2">"a"</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s2">"type"</span> <span class="o">=&gt;</span> <span class="s2">"integer"</span><span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"a"</span> <span class="o">=&gt;</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="no">JSON</span><span class="o">::</span><span class="no">Validator</span><span class="p">.</span><span class="nf">validate</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code></pre></figure>

<h2 id="rspec-json-schema-matcher">RSpec JSON Schema Matcher</h2>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">describe</span> <span class="s2">"Fetching the current user"</span> <span class="k">do</span>
  <span class="n">context</span> <span class="s2">"with valid auth token"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">"returns the current user"</span> <span class="k">do</span>
      <span class="n">user</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
      <span class="n">auth_header</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"Auth-Token"</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="p">.</span><span class="nf">auth_token</span> <span class="p">}</span>

      <span class="n">get</span> <span class="n">v1_current_user_url</span><span class="p">,</span> <span class="p">{},</span> <span class="n">auth_header</span>

      <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="nf">status</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">200</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">).</span><span class="nf">to</span> <span class="n">match_response_schema</span><span class="p">(</span><span class="s2">"user"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>参考: <a href="https://robots.thoughtbot.com/validating-json-schemas-with-an-rspec-matcher">Validating JSON Schemas with an RSpec Matcher</a></p>

<h2 id="ruby-json-schema-library">Ruby JSON Schema Library</h2>
<ul>
  <li><a href="https://github.com/ruby-json-schema/json-schema">ruby-json-schema/json-schema</a></li>
  <li><a href="https://github.com/brandur/json_schema">brandur/json_schema</a></li>
</ul>

<p>ダッシュとアンダースコア！ わかりにくい！！</p>

<h2 id="json-schema-vs-jsonschema">json-schema vs json_schema</h2>
<ul>
  <li>depending on <code class="highlighter-rouge">json-schema</code>:
    <ul>
      <li><a href="https://github.com/airbrake/airbrake">airbrake/airbrake</a></li>
      <li><a href="https://github.com/square/fdoc">square/fdoc</a></li>
    </ul>
  </li>
</ul>

<h2 id="json-schema-vs-jsonschema-1">json-schema vs json_schema</h2>
<ul>
  <li>depending on <code class="highlighter-rouge">json_schema</code>:
    <ul>
      <li><a href="https://github.com/interagent/committee">interagent/committee</a></li>
      <li><a href="https://github.com/interagent/prmd">interagent/prmd</a></li>
      <li><a href="https://github.com/increments/qiita-rb">increments/qiita-rb</a></li>
      <li><a href="https://github.com/r7kamura/rack-json_schema">r7kamura/rack-json_schema</a></li>
      <li><a href="https://github.com/r7kamura/jdoc">r7kamura/jdoc</a></li>
    </ul>
  </li>
</ul>

<h2 id="javascript-json-schema-library">JavaScript JSON Schema Library</h2>

<p>弊社フロンエンドエンジニアのオススメ2つ。</p>

<ul>
  <li><a href="https://github.com/mafintosh/is-my-json-valid">mafintosh/is-my-json-valid</a></li>
  <li><a href="https://github.com/epoberezkin/ajv">epoberezkin/ajv</a></li>
</ul>

<h2 id="json">JSON書くのツラい問題</h2>
<ul>
  <li>「閉じカッコがー!!」</li>
  <li>「カンマがー!!!!」</li>
  <li>「コメントがー!!!!!!」</li>
  <li>「クオテーションがー!!!!!!」</li>
</ul>

<p><strong>黙ってYAMLで書こう。</strong> こっちのが可読性もよいしミスも少ないし書きやすいです。</p>

<h2 id="json-schema-1">JSON Schemaの今とこれから</h2>
<ul>
  <li><a href="https://github.com/json-schema/json-schema">json-schema/json-schema</a></li>
</ul>

<p><img src="/images/posts/jsonschema/ima.png" alt="" /></p>

<ul>
  <li><a href="https://github.com/json-schema/json-schema/wiki/v5-Proposals">JSON Schema v5 Proposals</a>が出されている段階</li>
  <li><a href="https://github.com/json-schema/json-schema/issues">Issue</a>や<a href="https://groups.google.com/forum/#!forum/json-schema">Google Groups</a>を追うとよさげ</li>
  <li>v5への具体的なロードマップは引かれていない模様</li>
</ul>

<p><img src="/images/posts/jsonschema/korekara.png" alt="" /></p>

<h2 id="json-schema-2">JSON Schemaコラボでよかったこと</h2>
<ul>
  <li>バックエンドエンジニアとフロントエンドエンジニアの仕様の共通認識</li>
  <li>JSON Schemaを先に定義しておくことでバックエンドエンジニアとフロントエンドエンジニアが疎に開発できる</li>
  <li>JSON Schemaでバグの混入を防ぐ</li>
</ul>

<hr />

<h2 id="section-1">所感</h2>
<p>時間にシビアなLT形式だったので発表途中でぶった切られた。もう少し簡潔にすべきだったかもしれない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Railsのfind_eachの挙動を調べた]]></title>
    <link href="http://blog.toshimaru.net/rails-find_each/"/>
    <updated>2015-11-12T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/rails-find_each</id>
    <content type="html"><![CDATA[<p>Railsの<a href="http://apidock.com/rails/ActiveRecord/Batches/ClassMethods/find_each">find_each</a>がどんな挙動をするか気になったので調べてみた。</p>

<h2 id="findeach">find_eachとは</h2>

<p>バッチ処理などにおいてActiveRecordで効率的に大量データを処理したいときに使うメソッド。大量データまるっと全部取ってきて処理しちゃあアカンよねってことで徐々に処理をしていくときに使う。</p>

<blockquote>
  <p>Railsには find_each というメソッドが用意されています。通常の each メソッドを使用すると、全データをまとめてメモリに展開してから処理を開始します。そのため、十分にメモリに載るデータ量であれば何も問題ないですが、数百万、数千万というデータ量になってくるとメモリに載りきらずに溢れてしまって大変なことになります。</p>

  <ul>
    <li>find: 全データをメモリに展開してから処理</li>
    <li>find_each: 少しずつデータをメモリに展開しつつ処理</li>
  </ul>

  <p>そういうときには find_each メソッドを使いましょう。</p>
</blockquote>

<p><a href="http://blog.livedoor.jp/sasata299/archives/51882704.html">Railsで大量のデータをまとめて更新するならfind_each使うよね - (ﾟ∀ﾟ)o彡 sasata299’s blog</a></p>

<h2 id="findeach-1">素のfind_each</h2>

<p>まずはUserテーブルに1万件くらいデータを作って素直に<code class="highlighter-rouge">find_each</code>してみる。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; User.find_each{|a|}
  User Load (2.7ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (2.6ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 1001)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.7ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 2001)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre>
</div>

<p>デフォルトでは<code class="highlighter-rouge">order by id</code>で全件取得して1000件ずつ<code class="highlighter-rouge">limit 1000</code>して処理していくようなかたち。ではorderやlimitを付けてfind_eachしたらどうなるのだろう。</p>

<h2 id="orderfindeach">order付きfind_each</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; User.order(created_at: :desc).find_each{|a|}
Scoped order and limit are ignored, it's forced to be batch order and batch size
  User Load (3.8ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.0ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 1001)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (2.3ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 2001)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre>
</div>

<p><code class="highlighter-rouge">Scoped order and limit are ignored</code>ということでorderとlimitは無視されるようです。</p>

<h2 id="limitfindeach">limit付きfind_each</h2>

<p>じゃあlimitも試してみよう。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; User.limit(2000).find_each{|a|}
Scoped order and limit are ignored, it's forced to be batch order and batch size
  User Load (3.0ms)  SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.5ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 11003)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (3.4ms)  SELECT  `users`.* FROM `users` WHERE (`users`.`id` &gt; 12003)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre>
</div>

<p>やっぱりワーニングが出て無視された。</p>

<h2 id="wherefindeach">where付きfind_each</h2>

<p><code class="highlighter-rouge">where</code>を使って処理対象に条件を付けることもできます。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; User.where(notes: "1").find_each{|a|}
  User Load (4.3ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1'  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.8ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 11955)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.9ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 13954)  ORDER BY `users`.`id` ASC LIMIT 1000
  User Load (4.7ms)  SELECT  `users`.* FROM `users` WHERE `users`.`notes` = '1' AND (`users`.`id` &gt; 18067)  ORDER BY `users`.`id` ASC LIMIT 1000
  ...
</code></pre>
</div>

<p>しっかり全てのクエリに<code class="highlighter-rouge">users</code>.<code class="highlighter-rouge">notes</code> = ‘1’という条件が付いていますね。ところで、この`users`.`id` &gt; 11955 の11955というidはどこから出てきたんだろう？</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">while</span> <span class="n">records</span><span class="p">.</span><span class="nf">any?</span>
  <span class="n">records_size</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">size</span>
  <span class="n">primary_key_offset</span> <span class="o">=</span> <span class="n">records</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">id</span>
  <span class="k">raise</span> <span class="s2">"Primary key not included in the custom select clause"</span> <span class="k">unless</span> <span class="n">primary_key_offset</span>

  <span class="k">yield</span> <span class="n">records</span>

  <span class="k">break</span> <span class="k">if</span> <span class="n">records_size</span> <span class="o">&lt;</span> <span class="n">batch_size</span>

  <span class="n">records</span> <span class="o">=</span> <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">primary_key</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">primary_key_offset</span><span class="p">)).</span><span class="nf">to_a</span>
<span class="k">end</span></code></pre></figure>

<p>ポイントとなっているコード箇所を抜き出すとここ。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>primary_key_offset = records.last.id
relation.where(table[primary_key].gt(primary_key_offset))
</code></pre>
</div>

<p>最初に取得した1000件のうちの<code class="highlighter-rouge">last.id</code>を取得してそれより大きいidを条件として次の1000件を取得する、というようになっているようです。</p>

<h2 id="section">まとめ</h2>
<ul>
  <li>find_eachはデフォルトで1000件ずつ処理する</li>
  <li>find_eachにおいてorderとlimitは無視される</li>
  <li>where付きの場合は1000件取得してその中のlast.idを使ってさらに次の1000件を取得してループを回していく</li>
</ul>

<h3 id="section-1">参考</h3>
<ul>
  <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Batches.html">ActiveRecord::Batches</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rubyの破壊的メソッドと非破壊的メソッドのパフォーマンス比較]]></title>
    <link href="http://blog.toshimaru.net/destructive-method-performance/"/>
    <updated>2015-11-06T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/destructive-method-performance</id>
    <content type="html"><![CDATA[<p>Rubyの破壊的メソッドと非破壊的メソッドってどっちが速いのだろう？ 直感的には破壊的メソッドのほうが速そうだけど実際は…ということで調べてみた。</p>

<p>Rubyのバージョンは2.2です。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'benchmark'</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100_000</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"非破壊的"</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="p">{</span><span class="ss">a: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">b: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">c: </span><span class="mi">3</span><span class="p">}.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">d: </span><span class="mi">4</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"破壊的"</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="p">{</span><span class="ss">a: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">b: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">c: </span><span class="mi">3</span><span class="p">}.</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">d: </span><span class="mi">4</span><span class="p">)</span>  <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span></code></pre></figure>

<div class="highlighter-rouge"><pre class="highlight"><code>user     system      total        real
非破壊的  0.330000   0.010000   0.340000 (  0.337557)
破壊的  0.170000   0.000000   0.170000 (  0.177394)
</code></pre>
</div>

<p>破壊的のほうが速い。</p>

<blockquote>
  <p>破壊的メソッド (「!」が付くメソッド) はそうでないのに比べ概して高速。 しかし最近は非破壊的メソッドも高速化されてきているので以前ほど 違わなくなってきているのは確かだ。 たとえば gsub と gsub! だと作業自体は gsub のほうが高速だったりする。 計測してみると非破壊的メソッドが遅いことが多いのは、 無駄なオブジェクトが増えて GC が起きているからである。</p>
</blockquote>

<p>via. <a href="http://i.loveruby.net/w/OptimizingRubyProgram.html">LoveRubyNet Wiki: OptimizingRubyProgram</a></p>

<p>なるほど。<code class="highlighter-rouge">gsub</code>でも検証してみよう。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"非破壊的"</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="s2">"hello,</span><span class="se">\n</span><span class="s2">world</span><span class="se">\n</span><span class="s2">"</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/(\r\n|\r|\n)/</span><span class="p">,</span> <span class="s2">"&lt;br /&gt;"</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"破壊的"</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="s2">"hello,</span><span class="se">\n</span><span class="s2">world</span><span class="se">\n</span><span class="s2">"</span><span class="p">.</span><span class="nf">gsub!</span><span class="p">(</span><span class="sr">/(\r\n|\r|\n)/</span><span class="p">,</span> <span class="s2">"&lt;br /&gt;"</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span></code></pre></figure>

<div class="highlighter-rouge"><pre class="highlight"><code>user     system      total        real
非破壊的  0.410000   0.010000   0.420000 (  0.420611)
破壊的  0.420000   0.000000   0.420000 (  0.418214)
</code></pre>
</div>

<p>こちらは結果はほとんど変わらなかった。</p>

<h2 id="section">まとめ</h2>

<p>多くの場合、破壊的メソッドのほうが速い。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macbookでファン・照明・電源に問題が生じたときはSMCリセット]]></title>
    <link href="http://blog.toshimaru.net/macbook-smc-reset/"/>
    <updated>2015-10-07T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/macbook-smc-reset</id>
    <content type="html"><![CDATA[<p>ファンが周り続けたときにSMCリセットしたら解決したよ、という話。</p>

<h2 id="section">発生した問題</h2>
<ul>
  <li>熱持ってるわけでもないし、CPU食いつぶされているわけでもないのに、<strong>ファンがフル回転</strong></li>
  <li><strong>バッテリーの残り容量が出なくなる</strong></li>
</ul>

<p>そんなときはSMCリセット。</p>

<h2 id="smc">SMCリセットとは</h2>

<p>SMCとはSystem Management Controllerの略。System Management Controllerとはシステム管理コントローラのこと。</p>

<p>SMCはMacの電源関係を処理するコンピュータチップのことで、システム起動、スリープ、バッテリーなど、電源関係のハードウエアをコントロールします。</p>

<h2 id="smc-1">SMCリセット手順</h2>

<p>公式の下記ドキュメントが最も参考になります。</p>

<p><a href="https://support.apple.com/ja-jp/HT201295">Mac の SMC (システム管理コントローラ) をリセットする - Apple サポート</a></p>

<p>具体的にはMacbook Airで以下の手順となります。</p>

<ol>
  <li>コンピュータをシステム終了します。</li>
  <li>MagSafe 電源アダプタまたは USB-C 電源アダプタをコンセントに接続し、コンピュータに接続します。</li>
  <li>内蔵キーボードで、「(左の) shift + control + option」キーを押しながら、電源ボタンを押します。</li>
  <li>3 つのキー全部と電源ボタンを同時に放します。</li>
  <li>電源ボタンを押してコンピュータを起動します。</li>
</ol>

<h2 id="section-1">参考</h2>
<ul>
  <li><a href="http://inforati.jp/apple/mac-tips-techniques/hardware-hints/how-to-reset-the-system-management-controller-of-mac.html">MacのSMCを初期化してスリープやバッテリーのトラブルなどに対処する方法 / Inforati</a></li>
  <li><a href="http://digitalnetcreate.com/blog/mac/mbafan/">MacBookAirのファンが止まらない⇒解決しました！ | フリーランスの話のタネ</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[コマンドラインで複数行を1行にまとめる]]></title>
    <link href="http://blog.toshimaru.net/join-lines-command/"/>
    <updated>2015-09-30T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/join-lines-command</id>
    <content type="html"><![CDATA[<p>やりたかったことは、コマンドラインで複数行の標準入力を受け取ってそれを１行にカンマ区切りにして出力すること。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cat text
aaaa
bbbb
cccc

$ cat text | tr '\n' ','
aaaa,bbbb,cccc,%
</code></pre>
</div>

<p>こんな感じで<code class="highlighter-rouge">tr</code>を使って改行コードを置換してやればカンマ区切りで1行にできる。</p>

<h3 id="section">もともと</h3>

<p>もともとやりたかったのはこんな感じのこと。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ echo '{ "employees":[{"firstName":"John", "lastName":"Doe"}, {"firstName":"Anna", "lastName":"Smith"}, {"firstName":"Peter","lastName":"Jones"} ] }' | jq '.employees[] .firstName' | tr '\n' ',' | awk '{ print "result = [" $1 "]" }'
result = ["John","Anna","Peter",]
</code></pre>
</div>

<p>curlでJSONをGETしてそれをjqでパースして出たリストをカンマ区切りで出力する、みたいなやつ。</p>

<h3 id="section-1">参考</h3>
<ul>
  <li><a href="http://stackoverflow.com/questions/2764051/how-to-join-multiple-lines-of-file-names-into-one-with-custom-delimiter">linux - How to join multiple lines of file names into one with custom delimiter? - Stack Overflow</a></li>
  <li><a href="http://tbpgr.hatenablog.com/entry/20120309/1331314857">tr | 標準入力の内容を置換、削除する - Tbpgr Blog</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Gem Configuration Pattern]]></title>
    <link href="http://blog.toshimaru.net/ruby-configuration-pattern/"/>
    <updated>2015-09-01T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/ruby-configuration-pattern</id>
    <content type="html"><![CDATA[<p>railsのgemでよくみかける初期設定ファイル、<code class="highlighter-rouge">config/initializers/foo.rb</code>。このような初期設定のインターフェースをgem内に作る場合、いったいどうしたら良いでしょうか。</p>

<h2 id="section">めざす完成形はコレ！</h2>

<p>完成系として、下記を想定してみます。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># config/initializers/konfig.rb</span>
<span class="no">Konfig</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">my_value</span> <span class="o">=</span> <span class="s1">'my configuration value'</span>
<span class="k">end</span></code></pre></figure>

<h2 id="configure">configureメソッドを用意</h2>

<p>まずは<code class="highlighter-rouge">module</code>と<code class="highlighter-rouge">configure</code>というクラスメソッドを用意します。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Konfig</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">configure</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h2 id="configuration">Configurationクラス</h2>

<p>次に実際の設定値が入る<code class="highlighter-rouge">Configuration</code>クラスを用意します。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Configuration</span>
  <span class="kp">attr_accessor</span> <span class="ss">:my_value</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@my_value</span> <span class="o">=</span> <span class="s1">'default value'</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h2 id="section-1">完成形</h2>

<p>次にこれを組み合わせてみましょう。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Konfig</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">configure</span>
      <span class="k">yield</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">configuration</span>
      <span class="vi">@configuration</span> <span class="o">||=</span> <span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Configuration</span>
    <span class="kp">attr_accessor</span> <span class="ss">:my_value</span>

    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@my_value</span> <span class="o">=</span> <span class="s1">'default value'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>これでインスタンス化された<code class="highlighter-rouge">Configuration</code>クラスが出てきます。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; Konfig.configure {|config| p config}
#&lt;Konfig::Configuration:0x007ff5dfba4a50 @my_value="default value"&gt;
</code></pre>
</div>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Konfig</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">my_value</span> <span class="o">=</span> <span class="s2">"abc"</span>
<span class="k">end</span>
<span class="c1"># =&gt; "abc"</span>

<span class="no">Konfig</span><span class="p">.</span><span class="nf">configuration</span>
<span class="c1"># =&gt; #&lt;Konfig::Configuration:0x007fa9730aace8 @my_value="abc"&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">configure</code>で<code class="highlighter-rouge">Configuration</code>インスタンス作っててブロック内の<code class="highlighter-rouge">config</code>変数で<code class="highlighter-rouge">Configuration</code>インスタンスに設定注入していくようなイメージですね。</p>

<h3 id="section-2">参考</h3>
<ul>
  <li><a href="https://robots.thoughtbot.com/mygem-configure-block">MyGem.configure Block</a></li>
  <li><a href="http://jimsei.hatenablog.com/entry/20120721/1342855783">クラスインスタンス変数にアクセサを利用しアクセスする - ひたすら事務</a></li>
  <li><a href="http://o.inchiki.jp/obbr/168">Rubyのクラスインスタンス変数をアクセサで定義する</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docomo雑談対話APIでリプライ返すhubotプラグイン作った]]></title>
    <link href="http://blog.toshimaru.net/hubot-docomo-chatter/"/>
    <updated>2015-08-30T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/hubot-docomo-chatter</id>
    <content type="html"><![CDATA[<p>五番煎じくらいになりますが、docomo雑談対話APIを使ってリプライを返すhubotプラグインを作りました。</p>

<p><a href="https://github.com/toshimaru/hubot-docomochatter">toshimaru/hubot-docomochatter</a></p>

<ul>
  <li><a href="https://github.com/toshimaru/docomochatter">toshimaru/docomochatter</a>というシンプルなAPIクライアントをまず作り、それを利用するかたちでプラグインを作った</li>
  <li>既に定義された<code class="highlighter-rouge">hubot ping</code>などのコマンドに対しては返答しないようにし、マッチするコマンドが他にない場合にプラグインが反応するようにした。 このへんのやり方についてはこちらを参照した: <a href="http://qiita.com/hiconyan/items/baf6ac56129a26d8ac0c">Hubotで「どのコマンドにも一致しない」ときの処理 - Qiita</a></li>
  <li>ルーム毎（SlackでいうところのChannel）にcontextを保存するようにした</li>
  <li><code class="highlighter-rouge">DOCOMO_API_KEY</code>という環境変数使ってAPIアクセスする</li>
</ul>

<h3 id="section">参考</h3>
<ul>
  <li><a href="https://dev.smt.docomo.ne.jp/?p=docs.api.page&amp;api_name=dialogue&amp;p_name=api_reference">雑談対話 | docomo Developer support | NTTドコモ</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YAPC::Asia 2015で心に残ったトーク&スライド #yapcasia]]></title>
    <link href="http://blog.toshimaru.net/yapc-2015/"/>
    <updated>2015-08-23T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/yapc-2015</id>
    <content type="html"><![CDATA[<p>YAPC2015に行ってきました。その中で心に残ったトーク＆スライドのみを抜粋（直接トークを聴いたものもあるしそうでないものもある）。Perlは書けないのでPerl成分は少なめです。</p>

<p>まだ公開していないスライドもあるので後からさらに追加するかも。あと<strong>スライドの読み込みでページロードが遅くなっているのであしからず。</strong></p>

<h2 id="es6">ES6</h2>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/3aH36zv6gKAOcy" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/teppeis/effective-es6" title="Effective ES6" target="_blank">Effective ES6</a> </strong> from <strong><a href="//www.slideshare.net/teppeis" target="_blank">teppeis </a></strong> </div>

<ul>
  <li>ES6には未来があると思った</li>
  <li>PCでメモを取るには立ち見はツラい。せめて床座りだ</li>
</ul>

<h2 id="frontend-technology">Frontend Technology</h2>

<script async="" class="speakerdeck-embed" data-id="4d78b0afe4fa4e078544e80db2eb8bd1" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<ul>
  <li>時系列にフロントエンドのテクノロジーがまとめられていてわかりやすい <img class="emoji" title=":angel:" alt=":angel:" src="https://assets.github.com/images/icons/emoji/unicode/1f47c.png" height="20" width="20" align="absmiddle" /></li>
</ul>

<h2 id="http2">HTTP2</h2>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/xPIDup4I1Z0fS6" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/kazuho/http2-51888328" title="HTTP/2時代のウェブサイト設計" target="_blank">HTTP/2時代のウェブサイト設計</a> </strong> from <strong><a href="//www.slideshare.net/kazuho" target="_blank">Kazuho Oku</a></strong> </div>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/GiEBiNl1oDDHKz" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/Jxck/http2-web-web-over-http2-51943080" title="HTTP2 時代の Web - web over http2" target="_blank">HTTP2 時代の Web - web over http2</a> </strong> from <strong><a href="//www.slideshare.net/Jxck" target="_blank">Jxck :)</a></strong> </div>

<h2 id="section">リモートワーク</h2>

<script async="" class="speakerdeck-embed" data-id="5313f1eadabd46a4a4596b6cbe8fb0de" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<ul>
  <li>この言葉が非常に印象的だった: <em>The health and the qualilty of your product will be a direct reflection of the health and qualilty of your organization</em></li>
  <li>Conway’s law: <em>Organizations produce designs which are copies of the communication structures of these organizations</em></li>
</ul>

<h2 id="aws">AWS</h2>

<script async="" class="speakerdeck-embed" data-id="d890ef1876c54ee1b0470c1293db1cd7" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<ul>
  <li>良い知見がまとまっている</li>
</ul>

<h2 id="consul">Consul</h2>

<script async="" class="speakerdeck-embed" data-id="26bad8a4879b4be6a6b166d05a1f1c91" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<script async="" class="speakerdeck-embed" data-id="cde37ad797ab49dd92584770e9798d9a" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<h2 id="section-1">サービス運用</h2>

<script async="" class="speakerdeck-embed" data-id="4e5572293cef4fa8beabfaa16d70344b" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<script async="" class="speakerdeck-embed" data-id="b07a8c18db9444db891ff477fa860274" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/bVx5ctVFAPXH6h" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/shunsukekozawa5/ss-51890590" title="はてなブックマークのトピックページの裏側 in YAPC::Asia Tokyo 2015" target="_blank">はてなブックマークのトピックページの裏側 in YAPC::Asia Tokyo 2015</a> </strong> from <strong><a href="//www.slideshare.net/shunsukekozawa5" target="_blank">Shunsuke Kozawa</a></strong> </div>

<ul>
  <li><a href="http://songmu.github.io/slides/yapc-asia2015/#0">Mackerel開発におけるScalaとGo、そしてPerl</a></li>
  <li>はてな勢つよし…</li>
</ul>

<h2 id="oss">OSS</h2>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/3Q3IdJJc6HDWfW" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/tagomoris/how-to-createimprove-oss-products-and-its-community" title="How to create/improve OSS products and its community" target="_blank">How to create/improve OSS products and its community</a> </strong> from <strong><a href="//www.slideshare.net/tagomoris" target="_blank">SATOSHI TAGOMORI</a></strong> </div>

<ul>
  <li>OSSとのつきあいかた。OSSやっていく上で大事なことが書かれてる</li>
</ul>

<h2 id="section-2">ブログによる情報発信</h2>

<p><a href="http://yuuki.hatenablog.com/entry/the-art-of-blogging-technologies">YAPC::Asia 2015で技術ブログを書くことについて発表しました - ゆううきブログ</a></p>

<blockquote>
  <p>読みやすさを追求するために、文章自体を書くときに結構細かいことを意識しています。 意識しているのは以下のような内容です。</p>

  <ul>
    <li>段落のトピックセンテンスを意識する。その段落で述べることの概略を述べた一文を含める</li>
    <li>文をなるべく短くする。とはいえやり過ぎは返って流れにそって読みにくくなるため、きれいに読み下せるなら多少長くなってもよい</li>
    <li>箇条書きに頼らない。箇条書きは文と文とつなぐことに向いていないため、あくまで強調したいものを列挙するだけにとどめる</li>
    <li>「〜を行う」は冗長な表現なので使わない。大抵は「〜する」でシュッと言い切れる</li>
    <li>文の格を揃える。主語と述語が対応しているかを常に意識する</li>
    <li>不自然な体言止めを控える。小説やエッセイのようなものには向いているかもしれない</li>
    <li>適度にひらがなを混ぜる。漢字ばかりだと日本人には読みにくい。文の密度のバランスをとる</li>
    <li>同じ言い回しの連続を避ける。例えば、「〜だと思う」が連続しないようにする</li>
    <li>事実と意見を区別する。意見を述べた文の末尾は「〜だと考える。」「〜だと思う。」でくくる</li>
    <li>「〜だと考えられる」という表現を避ける。「考えられる」は考えている主体は自分なのに受け身になっていて、考えている主体を曖昧にしている</li>
  </ul>

  <p>曖昧な部分やわかりにくかったりぼかしたり部分は突っ込まれることもあるので、細部までこだわって丁寧に書こうとしています。</p>
</blockquote>

<h2 id="section-3">エンジニアの健康</h2>

<script async="" class="speakerdeck-embed" data-id="5248d18195884b3f9bf89e631302cbef" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<ul>
  <li>きちんとした姿勢と適度な運動、大事。</li>
</ul>

<h2 id="google">Google</h2>

<blockquote>
  <p><a href="https://speakerdeck.com/googlecloudjapan/deep-dive-into-google-cloud-technology">スライドはここ</a>に上げてありますが、これだけ見ても意味不明と思われるので、話した内容の要約をまとめブログ代わりに書こうかな、と思ったらかなり長文となってしまいました。</p>
</blockquote>

<ul>
  <li><a href="http://qiita.com/kazunori279/items/3ce0ba40e83c8cc6e580">GoogleCloudPlatform - YAPC Asia 2015「Google Cloud Platformの謎テクノロジーを掘り下げる」のまとめ - Qiita</a></li>
  <li>スライド参照するよりも上のQiitaの記事のほうが良さ気</li>
</ul>

<h2 id="isucon">ISUCON</h2>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/a9AbEpcmNp1vxX" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/kazeburo/isucon-yapcasia-tokyo-2015" title="ISUCONの勝ち方 YAPC::Asia Tokyo 2015" target="_blank">ISUCONの勝ち方 YAPC::Asia Tokyo 2015</a> </strong> from <strong><a href="//www.slideshare.net/kazeburo" target="_blank">Masahiro Nagano</a></strong> </div>

<h3 id="section-4">参考</h3>

<ul>
  <li>YouTubeに動画あります: <a href="https://www.youtube.com/playlist?list=PLzT643y4OYZp0K4YhPmmaLtnZzlVrbz0G">YAPC::Asia Tokyo 2015 - YouTube</a></li>
  <li>その他YAPCレポートがまとめられています <a href="http://yapcasia.org/2015/news/08/yapcasia-tokyo-2015-blog-entries.html">【随時更新中】YAPC::Asia Tokyo 2015 感想エントリまとめ | YAPC::Asia Tokyo 2015</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[他のrakeタスクに依存するrakeタスクの実行]]></title>
    <link href="http://blog.toshimaru.net/rake-dependency/"/>
    <updated>2015-08-22T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/rake-dependency</id>
    <content type="html"><![CDATA[<h2 id="rakerake">rakeタスクの前に別のrakeタスクを実行</h2>

<p>ある特定のRakeタスクを実行する前に別のタスクを実行したい場合、このようにタスクを書きます。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">task</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"x"</span> <span class="p">}</span>
<span class="n">task</span><span class="p">(</span><span class="ss">:y</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"y"</span> <span class="p">}</span>
<span class="n">task</span><span class="p">(</span><span class="ss">:z</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"z"</span> <span class="p">}</span>

<span class="n">desc</span> <span class="s2">"dependency rake task"</span>
<span class="n">task</span> <span class="ss">foo: </span><span class="p">[</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">,</span> <span class="ss">:z</span><span class="p">]</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"foo task"</span>
<span class="k">end</span></code></pre></figure>

<p>結果はこんな感じ。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ rake foo
x
y
z
foo task
</code></pre>
</div>

<p>タスク<code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, <code class="highlighter-rouge">z</code> が実行された後にタスク<code class="highlighter-rouge">foo</code>が実行されます。</p>

<h2 id="rakerake-1">rakeタスクの後に別のrakeタスクを実行</h2>

<p>ある特定のRakeタスクを実行する後に別のタスクを実行したい場合、<code class="highlighter-rouge">enhance</code>を使ってこのようにタスクを書けます。さっきの書いたタスクをenhanceしてみましょう。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">task</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"x"</span> <span class="p">}</span>
<span class="n">task</span><span class="p">(</span><span class="ss">:y</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"y"</span> <span class="p">}</span>
<span class="n">task</span><span class="p">(</span><span class="ss">:z</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"z"</span> <span class="p">}</span>

<span class="n">desc</span> <span class="s2">"dependency rake task"</span>
<span class="n">task</span> <span class="ss">foo: </span><span class="p">[</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">,</span> <span class="ss">:z</span><span class="p">]</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"foo task"</span>
<span class="k">end</span>

<span class="no">Rake</span><span class="o">::</span><span class="no">Task</span><span class="p">[</span><span class="s2">"foo"</span><span class="p">].</span><span class="nf">enhance</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"foo enhancing task"</span>
<span class="k">end</span></code></pre></figure>

<p>結果はこんな感じ。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ rake foo
x
y
z
foo task
foo enhancing task
</code></pre>
</div>

<p><code class="highlighter-rouge">enhance</code>の中にかいた処理はしっかり<code class="highlighter-rouge">foo</code>タスクのあとに実行されていますね。</p>

<h3 id="section">参考</h3>
<ul>
  <li><a href="http://www.dan-manges.com/blog/modifying-rake-tasks">Modifying Rake Tasks - Dan Manges’s Blog</a></li>
  <li><a href="https://github.com/ruby/rake">ruby/rake</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日米ワークスタイル比較]]></title>
    <link href="http://blog.toshimaru.net/work-style-difference/"/>
    <updated>2015-08-05T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/work-style-difference</id>
    <content type="html"><![CDATA[<p><a href="/job-hunting-fin/">就職活動が完了</a>して日本の会社に勤め始めてはや１年が経った。カナダ・バンクーバーでの就労経験を経て、日本に帰国後日本の会社でWEBエンジニアとして１年間働いてみて思うところ（主に日米の技術者のワークスタイルの違いを中心に）をまとめてみようと思う<sup id="fnref:canada-van"><a href="#fn:canada-van" class="footnote">1</a></sup>。</p>

<h2 id="vs-">北米の働き方 vs 日本の働き方</h2>

<p>北米は定時で帰宅する一方、日本は残業前提なところがある。</p>

<p>僕の場合、北米で働いていたときは8時間の定められた労働時間後（9:00~17:00）すぐに帰宅していた。MAX残業してもせいぜい１時間、18:00前には必ず職場を出ていた。</p>

<h3 id="section">スタートアップはバリバリ働く!?</h3>

<p>僕がカナダで務めていた会社は従業員10人ほどのスタートアップだった。僕の中で国は関係なく「小さい会社 = （人数が少ない分）バリバリ働く」という仮設があったので、僕の務めた会社も残業は日本ほどないにせよそれなりにある思っていた。</p>

<p>だけどその仮説は間違っていた。その会社は小さなスタートアップが集まるシェアオフィスの一角にあったのだが、どの会社であれ午後6前には基本的にみんな帰っていた。そこに入っていた全ての会社がその時間なのだから、会社の規模の大小は関係無いのだろう。会社の規模にかかわらずみんな定時に帰ってたのだ。</p>

<h3 id="section-1">残業が当たり前な日本のワークスタイル</h3>

<p>カナダに行く前、僕は日本のいわゆるSIの会社に勤めていた。当時は残業しない日のほうが圧倒的に少なかった。むしろ「一時間くらいの残業は当たり前」という感じで働いていたので、１時間の残業で済めば「よっしゃ！今日は早く帰れた！」という感じ。</p>

<p>一番問題だと感じるのは「残業はして当然」という空気感であり、別にこれは会社として誰かが公式に言ったわけでもなかったし、早く帰ったら査定に響くというクソみたいなことは全くなかったのだけど、漠然と帰りにくい空気感はあった。</p>

<p>「いや、そんな空気なんてもん無視すればいいじゃん」っていうのはごもっともで僕も大賛成なんだけど、なんかこうみんなが帰らずに働いていることがさも当たり前のようにすごくナチュラルに働いているもんだから、僕もあたかも働いているのが当然なことだという感じで働き、それが習慣化していった。惰性的な労働、忌むべきモノだ。</p>

<h3 id="section-2">残業する人=仕事のできない人</h3>

<p>こういう空気を感じちゃったりとか周囲の雰囲気に流されている時点で「あぁ、わたしって日本人」と残念な気持ちになるのだけど、そういう空気を作らないという意味では上司が真っ先に早く帰ることは重要だと思う。もちろん仕事をしっかりこなした上で。</p>

<p>カナダでは全員定時に帰っているもんだから、<strong>基本的に定時に帰っていない人・帰れない人っていうのは仕事のできない人・遅い人</strong> というレッテルがはられる印象があった。残業30分しようものなら自分一人だけ会社に取り残されるので居心地が非常に悪い。「仕事が遅いせいで仕事が終わっていないのだ」という感覚に襲われた（実際はそんなことはないのだけど）。なのでカナダで働いていたときは自然と業務時間内に仕事に終わらせようという気持ちになり、その中で最高のパフォーマンスを出そうという気持ちになった。</p>

<p>あとみんな定時に帰ることが前提になっているので、定時の一時間前に仕事の依頼を飛ばすであったり、帰ろうとしているときにトコトコと歩いてきて「ちょっと聞きたいことがあるんだけど？？」みたいなアホなことは絶対にしない（本当の本当に緊急時以外は）。</p>

<h3 id="section-3">タスクの積み方・こなし方</h3>

<p>ボスからのタスクの積み方、デベロッパーのタスクのこなし方も違いがあった。ボスからのタスクは降りてくる時点できちんと優先度付けされていて、開発者にたいしては「最低限これはやってね」という高優先度なタスクがメインで振られていて、タスクを過度に積みすぎているということはなかった。</p>

<p>開発者側としてもタスクのこなし方として「今週中のタスクが終らなかったから気合で頑張る」みたいなことはなくて、終らなかったら終らなかったで仕方ないという感じで淡々と仕事してた。その結果、下記のようなシチュエーションも垣間見た。</p>

<blockquote>
  <p>デッドラインに遅れるのはけっこう平気でしてる。デッドラインが今週中というようなタスクを「あとちょっとで終わる！」「ほぼ完了と言って良い」なんていいながら3週間くらい平気でスケジュール遅延している。そしてそのタスクの担当者はバケーションに入るとかで結局中途半端な感じのタスクを置き土産として長期休暇に入っていった。</p>
</blockquote>

<p><a href="/my-impression-after-working-2-months/">2ヶ月間WEBエンジニアとして海外で働いてみて感じたこと</a></p>

<h2 id="vs--1">北米の給料 vs 日本の給料</h2>

<p>給与面に関しては北米で働いたほうが断然良い。</p>

<p><img src="http://cdn-ak.f.st-hatena.com/images/fotolife/p/paiza/20140724/20140724174014.png" alt="" /></p>

<p><a href="http://paiza.hatenablog.com/entry/2014/07/23/IT%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%AE%E5%9C%B0%E4%BD%8D%E3%81%A8%E3%81%AF%EF%BC%9F%E5%9B%BD%E5%88%A5%E3%80%81%E8%81%B7%E7%A8%AE%E5%88%A5%E3%81%AE%E5%B9%B4%E5%8F%8E%E6%AF%94%E8%BC%83">ITエンジニアの地位とは？国別、職種別の年収比較から見えるもの - paiza開発日誌</a></p>

<p>本データによると日本とアメリカのエンジニアの平均年収は倍近く違う<sup id="fnref:money"><a href="#fn:money" class="footnote">2</a></sup>。日本が約400万なのに対してアメリカでは約800万円。僕の北米で就職活動した身としての肌感は、日本のWEBエンジニアの給与レンジは400万円〜800万円である一方、北米のレンジは最低600万円から最高1200万とかそういう感じ。</p>

<h3 id="section-4">レベル別給与レンジ</h3>

<p>具体的にレベル別にまとめる下記のような給与レンジだった。</p>

<ul>
  <li>Junior Level: 600~800万円</li>
  <li>Intermediate Level: 800~1000万円</li>
  <li>Senior Level: 1000~1200万円 or それ以上</li>
</ul>

<p>僕もカナダで求職していたときはお金は本当に最低限でいいやくらいに考えていたのだけど、エンジニアの給与ベースが良い分、結果的に日本と同水準くらいかむしろ少し多いくらいの貰えていた。</p>

<blockquote>
  <p>英語の部分で実力不足を感じたので別に給与とか（こっちで生活できる程度に貰えれば）どーでもいいや、って口だったけど技術スキルの部分で会社に認めてもらって日本にいたときと同じ水準くらいの給与は貰えている。嬉しい誤算だ。</p>
</blockquote>

<p><a href="/my-impression-after-working-2-months/">2ヶ月間WEBエンジニアとして海外で働いてみて感じたこと</a></p>

<p>お金が欲しくて腕に自身があるエンジニアならば、カナダのバンクーバーやアメリカ、サンフランシスコあたりに行って働く方が確実に稼げると思う。</p>

<h3 id="section-5">開発者の社会的地位</h3>

<p>給与が高い分、開発者の社会的地位も高いと感じた。オフィスも開発者が働きやすいように設計されている（勉強会が開けるようなスペース、無料で飲めるビール・ドリンク類）。毎週のように何かしら開発者が集まるミートアップが開催され、無料のピザ・ビールがふるまわれる。「手に職を」といったときに数ある選択肢の中でデベロッパーの優位性は高まっている印象を受けた。</p>

<p>一方、日本だとIT技術者の印象って「IT土方」という言葉があることからしてそこまで良くはない。最近は良くはなってきていると感じるけど、とても良いというレベルには至っていないと感じる。</p>

<h2 id="section-6">北米と日本のエンジニアのレベルについて</h2>

<p>「著名なオープンソースの多くはアメリカから出ているし、世界的に有名なGoogleなどのIT会社もアメリカからたくさん出ているしやっぱITの聖地はアメリカだわー、スーパーハッカー多いに違いないわー 間違いないわー」</p>

<p>そう考えていた時期が僕にもありました…。</p>

<p>いや、アメリカから著名なオープンソースも出てるのは事実だし世界に羽ばたくスタートアップが多く育つ土壌があることも間違いないのだけど、エンジニアのレベルとして考えたときに日本の技術者と北米の技術者でそこまで変わらないんじゃないかってこと。</p>

<p>どこ行ってもそうだけど、デキる人はデキるしデキない人はデキない。別に北米で働いても技術者のレベルの平均値が高いなーという印象は僕はなかった（ただ実力とか結果にシビアではある）。</p>

<h2 id="section-7">最後に</h2>
<p>一年日本で働いてみて、改めて日本と北米のワークスタイルの違いについて整理したくて本記事を書いた。</p>

<p>とくにオチみたいなものは用意していないのだけど、日米の技術者のワークスタイルを比較したときにやっぱり日本の技術者の働き方はまだまだ改善できるなと思う。日本で働くエンジニアの一人としてその辺をもっと整備していくためにはどうしたら良いかということを考えてモンモンとしている最近。</p>

<div class="footnotes">
  <ol>
    <li id="fn:canada-van">
      <p>僕が働いたのはカナダのバンクーバーですが本記事では「北米」としてまとめています。実際のところは同じ北米でも西海岸と東海岸で働き方・雰囲気はけっこう違ったりします。 <a href="#fnref:canada-van" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:money">
      <p>物価や税金の違いがあるので額面だけでの単純な比較はできないのだが、ここで引用している図では「物価指数後」の図なのでその辺も加味されています。 <a href="#fnref:money" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashキーのStringアクセスとSymbolアクセスのパフォーマンス比較]]></title>
    <link href="http://blog.toshimaru.net/string-vs-symbol-in-hash/"/>
    <updated>2015-07-24T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/string-vs-symbol-in-hash</id>
    <content type="html"><![CDATA[<p>HashキーのStringアクセスとSymbolアクセスはどっちが早いのか？ ということで比較してみます。コードは<a href="http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/">こちら</a>を参考にしました。</p>

<h2 id="section">前提条件</h2>

<p>比較として使用したRubyのバージョンは下記です。</p>

<ul>
  <li>Ruby 2.1.6</li>
  <li>Ruby 2.2.2</li>
</ul>

<p>またベンチマークには下記のgemを使用しています。</p>

<ul>
  <li><a href="https://github.com/evanphx/benchmark-ips">evanphx/benchmark-ips</a></li>
</ul>

<h3 id="section-1">ベンチマーク・コード</h3>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="no">STRING_HASH</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"foo"</span> <span class="o">=&gt;</span> <span class="s2">"bar"</span> <span class="p">}</span>
<span class="no">SYMBOL_HASH</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s2">"bar"</span>  <span class="p">}</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"string"</span><span class="p">)</span> <span class="p">{</span> <span class="no">STRING_HASH</span><span class="p">[</span><span class="s2">"foo"</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"symbol"</span><span class="p">)</span> <span class="p">{</span> <span class="no">SYMBOL_HASH</span><span class="p">[</span><span class="ss">:foo</span><span class="p">]</span>  <span class="p">}</span>
<span class="k">end</span></code></pre></figure>

<h2 id="ruby-21">Ruby 2.1</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>Calculating -------------------------------------
              string    70.713k i/100ms
              symbol    93.805k i/100ms
-------------------------------------------------
              string      3.356M (± 7.6%) i/s -     16.688M
              symbol      6.363M (± 8.3%) i/s -     31.612M
</code></pre>
</div>

<p>シンボルを使った方がハッシュのアクセスは2倍ほど速い。</p>

<h2 id="ruby-22">Ruby 2.2</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>Calculating -------------------------------------
              string    77.873k i/100ms
              symbol    78.367k i/100ms
-------------------------------------------------
              string      5.604M (± 7.8%) i/s -     27.879M
              symbol      6.463M (± 8.2%) i/s -     32.130M
</code></pre>
</div>

<p>シンボルを使った方がハッシュのアクセスは速いが、Stringでのハッシュのアクセス速度はシンボルのそれと大きく変わらない値となっている。</p>

<h2 id="section-2">結論</h2>
<p>シンボルを使ったキーの方がHashのアクセスは速い。2.1だとそれが顕著。しかし2.2以降はそう変わらない速度になってきている。</p>

<hr />

<h3 id="json">【おまけ】JSONの場合</h3>

<p>JSONをパースした場合。下記のコードで<code class="highlighter-rouge">symbolize_names</code>した場合とそうでない場合を比較。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'json'</span>
<span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="no">SAMPLE_JSON</span> <span class="o">=</span> <span class="s1">'{"a": 1, "b": 2, "c": 3}'</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"string"</span><span class="p">)</span> <span class="p">{</span> <span class="nb">hash</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">SAMPLE_JSON</span><span class="p">);</span> <span class="nb">hash</span><span class="p">[</span><span class="s2">"c"</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"symbol"</span><span class="p">)</span> <span class="p">{</span> <span class="nb">hash</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">SAMPLE_JSON</span><span class="p">,</span> <span class="ss">symbolize_names: </span><span class="kp">true</span><span class="p">);</span> <span class="nb">hash</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span></code></pre></figure>

<h3 id="ruby-21-1">Ruby 2.1</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>Calculating -------------------------------------
          string    11.910k i/100ms
          symbol    11.072k i/100ms
-------------------------------------------------
          string    148.480k (± 4.5%) i/s -    750.330k
          symbol    141.624k (± 5.3%) i/s -    708.608k
</code></pre>
</div>

<h3 id="ruby-22-1">Ruby 2.2</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>Calculating -------------------------------------
              string    11.980k i/100ms
              symbol    11.129k i/100ms
-------------------------------------------------
              string    150.421k (± 6.5%) i/s -    754.740k
              symbol    137.871k (± 9.1%) i/s -    689.998k
</code></pre>
</div>

<p><code class="highlighter-rouge">symbolize_names</code>せずに純粋なStringのほうが若干速いという結果が得られた。</p>

<h3 id="section-3">参考</h3>
<ul>
  <li><a href="http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/">Unraveling String Key Performance in Ruby 2.2</a></li>
  <li><a href="http://blog.kazu69.net/2014/11/29/ruby-benchmarks-to-measure-benchmark-ips-was-so-helpful/">Rubyのベンチマークを計測するのにbenchmark-ipsが便利そうだった | 69log</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RailsアプリケーションをLAN内に公開する]]></title>
    <link href="http://blog.toshimaru.net/publish-rails-app-in-lan/"/>
    <updated>2015-07-17T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/publish-rails-app-in-lan</id>
    <content type="html"><![CDATA[<p>普通に<code class="highlighter-rouge">rails server</code>した場合、デフォルトでlocalhost:3000でリッスンするので、LAN内の外部のクライアントからLocal IPではアクセスすることができません。(Railsのバージョンは4.2.3です)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ rails server
=&gt; Booting WEBrick
=&gt; Rails 4.2.3 application starting in development on http://localhost:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
</code></pre>
</div>

<p>これをLAN内に公開したい場合はどうするか。下記のように<code class="highlighter-rouge">binding</code>オプションを付けてやります。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ rails server --binding=0.0.0.0
=&gt; Booting WEBrick
=&gt; Rails 4.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
</code></pre>
</div>

<p>これで同じLAN内にいるクライアントからローカルIP（e.g. <code class="highlighter-rouge">192.168.1.10:3000</code> ）でRailsへとアクセス可能になります。</p>

<h3 id="section">参考</h3>
<ul>
  <li><a href="http://stackoverflow.com/questions/29132719/rails-application-not-visible-to-local-network">osx yosemite - Rails application not visible to local network - Stack Overflow</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQLファイルでRailsのスキーマ情報管理]]></title>
    <link href="http://blog.toshimaru.net/manage-schema-with-sql-in-rails/"/>
    <updated>2015-07-03T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/manage-schema-with-sql-in-rails</id>
    <content type="html"><![CDATA[<p>Railsでは<code class="highlighter-rouge">db:migrate</code>すると、デフォルトで<code class="highlighter-rouge">db/schema.rb</code>を生成しますが、SQLでスキーマ情報を管理することも可能です。下記のように<code class="highlighter-rouge">config/application.rb</code>内で<code class="highlighter-rouge">active_record.schema_format</code>を<code class="highlighter-rouge">:sql</code>と設定することで可能になります（デフォルト値は<code class="highlighter-rouge">:ruby</code>）。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># config/application.rb</span>
<span class="k">module</span> <span class="nn">Rails4TwitterClone</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">active_record</span><span class="p">.</span><span class="nf">schema_format</span> <span class="o">=</span> <span class="ss">:sql</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>これで<code class="highlighter-rouge">db/migrate</code>するとデフォルトのschema.rbではなく、<code class="highlighter-rouge">db/structure.sql</code>というSQLファイルを吐きます。</p>

<h2 id="structuresql">structure.sqlをロードする</h2>

<p>生成されたstructure.sqlファイルは、下記のコマンドでデータベースへロードできます。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rake db:structure:load
</code></pre>
</div>

<h2 id="sql">SQLファイルだけ欲しい場合</h2>

<p>sqlダンプファイルのみが欲しい場合は、<code class="highlighter-rouge">config.active_record.schema_format</code>の設定を変えずとも下記コマンドでstructure.sqlを生成することができます。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rake db:structure:dump
</code></pre>
</div>

<h3 id="section">参考</h3>
<ul>
  <li><a href="http://tech-kazuhisa.hatenablog.com/entry/20130902/1378126825">schema.rbじゃなくてstructure.sqlでスキーマ情報を管理しよう - tech-kazuhisa’s blog</a></li>
  <li><a href="http://edgeguides.rubyonrails.org/active_record_migrations.html#types-of-schema-dumps">Active Record Migrations — Ruby on Rails Guides</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AWS Summit Tokyo 2015で発表してきました]]></title>
    <link href="http://blog.toshimaru.net/aws-summit-tokyo-2015/"/>
    <updated>2015-06-05T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/aws-summit-tokyo-2015</id>
    <content type="html"><![CDATA[<p><a href="http://www.awssummit.tokyo/">AWS Summit Tokyo 2015</a>でGunosyのモバイルプッシュ通知基盤について発表してきました。下記が当日の発表スライドになります。</p>

<script async="" class="speakerdeck-embed" data-id="9d7bd2a0fda94826b67f162e2fd3bdbd" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<ul>
  <li><a href="https://speakerdeck.com/toshimaru/900mo-daunrodoapuri-gunosy-wozhi-eruda-gui-mo-mobairuputusiyutong-zhi-ji-pan-1">900万ダウンロードアプリ『Gunosy』を支える大規模モバイルプッシュ通知基盤 // Speaker Deck</a><sup id="fnref:longurl"><a href="#fn:longurl" class="footnote">1</a></sup></li>
</ul>

<h2 id="section">発表を追えて</h2>

<p>今回これほどの大舞台で30分以上（与えられた時間は40分）話すのは始めての機会でしたので、緊張しましたが悪いものではなく心地のよい緊張感でした。正直、私の発表の裏が<a href="https://speakerdeck.com/mirakui/developer-productivity-in-cookpad">Cookpadさんの発表</a>だったのでそんなに人は集まらないのかなーと想定していましたが、嬉しい事に約70-80名くらいの方々に聴講していただけました。（圧倒的感謝！）</p>

<p>40分という比較的長い枠でしたが時間にせかされることなくじっくり話せて大体35分強で発表を終えることができました。今回のように40分くらいの発表の場合、（スライドのスタイルにもよりますが）大体スライド枚数50~60枚程度が調度良いように感じました。あと、早く終わりすぎたり、時間オーバーしてしまうリスクを減らすためにも事前に最低一回発表を通しておいて時間をしっかり見積もっておくことは重要だと感じました。</p>

<p>余談になりますが、当日のTwitterタイムラインを見てるとカメラの音・フラッシュがうるさいという声が多く出てました。私の発表でもそうしたのですが、事前に資料をWEBにアップロードして講演最初にWEBに既にアップロード済みな旨を伝えるとよいと思いました。</p>

<h2 id="section-1">スライド中の参考リンク</h2>
<ul>
  <li><a href="http://monstar-lab.com/column/140911_01">【Android】GCMのregistrationIdの一意性 - Monstar Lab, Inc.</a></li>
  <li><a href="http://dev.classmethod.jp/cloud/aws/sns-mobile-token/">Amazon SNS のモバイルトークン管理についてのベストプラクティス ｜ Developers.IO</a></li>
  <li><a href="http://www.slideshare.net/conmame/sns-mobile-push">気軽なSNS Mobile Push の話</a></li>
  <li><a href="http://qiita.com/ykf/items/4978a9ccf0dd1cc6a19b">iOS8アップデートでアプリへのプッシュ通知でハマる点 - Qiita</a></li>
  <li><a href="http://www.slideshare.net/shimy_net/amazon-sns-mobile-push">Amazon SNS Mobile Push を使ってみる</a></li>
  <li><a href="https://developers.google.com/android/reference/com/google/android/gms/iid/InstanceID">InstanceID - Google APIs for Android - Google Developers</a></li>
</ul>

<h2 id="section-2">その他のリンク</h2>
<ul>
  <li><a href="http://dev.classmethod.jp/cloud/aws/awssummit-tokyo-2015-dev-05/">[レポート][Dev-05:Mobile] 900万ダウンロードアプリ『Gunosy』を支える大規模モバイルプッシュ通知基盤 #AWSSummit ｜ Developers.IO</a></li>
  <li><a href="https://twitter.com/hashtag/AWSSummit?src=hash">Tweets about #AWSSummit hashtag on Twitter</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:longurl">
      <p>speakerdeckのURLが非常に汚いですが公開した後に<a href="http://sotarok.hatenablog.com/entry/2014/10/11/133123">URLを制御できる</a>ことを教えてもらいました。URLを変更して元URLが404になるのも不便かと思いますので、今回はこの汚いURLでお許しください。 <a href="#fnref:longurl" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[video.js で m3u8 形式の動画ファイルをブラウザで再生する]]></title>
    <link href="http://blog.toshimaru.net/play-m3u8-video-in-browser/"/>
    <updated>2015-05-03T00:00:00+00:00</updated>
    <id>http://blog.toshimaru.net/play-m3u8-video-in-browser</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/videojs/video.js">video.js</a>を使ってm3u8形式の動画ファイルをSafari以外のブラウザでも再生する方法を紹介します。デモページは下のボタンから。</p>

<p><a href="http://toshimaru.net/demo/videojs-m3u8/" class="btn btn-primary">Demo</a></p>

<h2 id="section">動作環境</h2>

<p>下記環境で（現時点の最新版での）動作を確認しています。</p>

<ul>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
  <li>Safari</li>
</ul>

<p><strong>※要Flash</strong></p>

<h2 id="js">使うJSライブラリ</h2>
<ol>
  <li><a href="https://github.com/videojs/video.js">videojs/video.js</a>
    <ul>
      <li>基本素材。動画ファイルを様々なブラウザで再生できるようにする。</li>
    </ul>
  </li>
  <li><a href="https://github.com/videojs/videojs-contrib-media-sources">videojs/videojs-contrib-media-sources</a>
    <ul>
      <li>videoタグに動画ソースを流し込めるようにするvideo.jsプラグイン。</li>
      <li>W3Cのドラフト仕様<a href="https://w3c.github.io/media-source/">Media Source Extensions</a>が元のよう。</li>
    </ul>
  </li>
  <li><a href="https://github.com/videojs/videojs-contrib-hls">videojs/videojs-contrib-hls</a>
    <ul>
      <li>HLS(<code class="highlighter-rouge">m3u8</code>)形式の動画ファイルを再生可能にするvideo.jsプラグイン。</li>
      <li>HLSに対応していないブラウザでもFlash技術を通すことで再生可能にしているよう。</li>
    </ul>
  </li>
</ol>

<h2 id="usage">Usage</h2>

<p>全体HTMLファイルはこんな感じ。</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Video.js m3u8<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"css/video-js.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//cdnjs.cloudflare.com/ajax/libs/video.js/4.12.5/video.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"js/videojs-media-sources.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"js/videojs.hls.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>

    <span class="nt">&lt;h1&gt;</span>Video.js m3u8 demo page<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;video</span> <span class="na">id=</span><span class="s">"test"</span> <span class="na">class=</span><span class="s">"video-js vjs-default-skin"</span> <span class="na">height=</span><span class="s">"300"</span> <span class="na">width=</span><span class="s">"600"</span> <span class="na">controls</span><span class="nt">&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"//solutions.brightcove.com/jwhisenant/hls/apple/bipbop/bipbopall.m3u8"</span> <span class="na">type=</span><span class="s">"application/x-mpegURL"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/video&gt;</span>

    <span class="nt">&lt;script&gt;</span>
      <span class="kd">var</span> <span class="nx">player</span> <span class="o">=</span> <span class="nx">videojs</span><span class="p">(</span><span class="s1">'test'</span><span class="p">);</span>
      <span class="nx">player</span><span class="p">.</span><span class="nx">play</span><span class="p">();</span>
    <span class="nt">&lt;/script&gt;</span>

  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></figure>

<h3 id="cssjs">CSS/JS読み込み</h3>

<p>video.js, videojs-media-sources.js, videojs.hls.js 以外にもCSSを読み込まないとエラーが出て再生できなかったのでCSSも読み込むこと。</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"css/video-js.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span><span class="nt">&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//cdnjs.cloudflare.com/ajax/libs/video.js/4.12.5/video.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"js/videojs-media-sources.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"js/videojs.hls.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span></code></pre></figure>

<h3 id="video">videoタグ</h3>

<p>適当なクラスを持った<code class="highlighter-rouge">&lt;video&gt;</code>をタグに<code class="highlighter-rouge">height</code>, <code class="highlighter-rouge">width</code>を定義してやって、中に<code class="highlighter-rouge">type="application/x-mpegURL"</code>と<code class="highlighter-rouge">src</code>を持った<code class="highlighter-rouge">&lt;source&gt;</code>タグを入れてやる。</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;video</span> <span class="na">id=</span><span class="s">"test"</span> <span class="na">class=</span><span class="s">"video-js vjs-default-skin"</span> <span class="na">height=</span><span class="s">"300"</span> <span class="na">width=</span><span class="s">"600"</span> <span class="na">controls</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"//solutions.brightcove.com/jwhisenant/hls/apple/bipbop/bipbopall.m3u8"</span> <span class="na">type=</span><span class="s">"application/x-mpegURL"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/video&gt;</span></code></pre></figure>

<h3 id="javascript">JavaScript</h3>

<p><code class="highlighter-rouge">videojs()</code>内にvideoタグのIDでplayerを生成してplay。</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">player</span> <span class="o">=</span> <span class="nx">videojs</span><span class="p">(</span><span class="s1">'test'</span><span class="p">);</span>
<span class="nx">player</span><span class="p">.</span><span class="nx">play</span><span class="p">();</span></code></pre></figure>

<h2 id="section-1">最後に</h2>

<p>クロスオリジンな動画リソースを読み込むときは CORS(Cross-Origin Resource Sharing) の設定を適切にしてやる必要があることに注意！</p>

<hr />

<h2 id="section-2">追記</h2>

<p>本記事を参考に書かれた下記の記事も参考になるかもしれません。</p>

<p><a href="http://akiyoko.hatenablog.jp/entry/2015/08/11/015852">Video.js を使って HLS形式の動画をストリーミング再生する - akiyoko blog</a></p>
]]></content>
  </entry>
  

</feed>
